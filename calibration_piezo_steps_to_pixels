import numpy as np
import time
import clr
import matplotlib.pyplot as plt
from scipy.stats import linregress
import pythoncom
from functions import *
try:
    pythoncom.CoInitialize()
except pythoncom.com_error:
    pass


##Piezo inladen
clr.AddReference(r"C:\Program Files\Thorlabs\Kinesis\Thorlabs.MotionControl.DeviceManagerCLI.dll")
clr.AddReference(r"C:\Program Files\Thorlabs\Kinesis\Thorlabs.MotionControl.GenericMotorCLI.dll")
clr.AddReference(r"C:\Program Files\Thorlabs\Kinesis\Thorlabs.MotionControl.KCube.InertialMotorCLI.dll")
from Thorlabs.MotionControl.DeviceManagerCLI import *
from Thorlabs.MotionControl.GenericMotorCLI import *
from Thorlabs.MotionControl.KCube.InertialMotorCLI import *

## camera, info van:https://pythonforthelab.com/blog/getting-started-with-basler-cameras/ 
# camera verbinden
from pypylon import pylon

cam = camera_setup()

def plot_calibration(calibrations, output_file, labels=None, combine_datasets=False):
    """
    TO DO: moet dit uberhaupt wel een functie zijn? want je plot iets, is dat niet eenmalig? -> wordt wel in dit script vaker gebruikt
    berekent wel ook de lijn, das wel belangrijk en wordt meerdere keren gedaan
    - output van plot is nu ingewikkeld met gecombineerde datasets enzo, hoe doe ik alleen de goede fits eruit halen? die moeten nml gebruikt worden in het

    Args:
        calibrations (_type_): _description_
        output_file (_type_): _description_
        labels (_type_, optional): _description_. Defaults to None.
        combine_datasets (bool, optional): _description_. Defaults to False.

    Raises:
        ValueError: _description_
    """
    if not calibrations:
        raise ValueError("No calibration data provided")

    if labels is None:
        labels = [f"Data {i+1}" for i in range(len(calibrations))]

    colors = plt.cm.tab10(np.linspace(0, 1, len(calibrations)))
    fig, (ax_x, ax_y) = plt.subplots(1, 2, figsize=(12, 5))

    for i, (all_runs, label, color) in enumerate(zip(calibrations, labels, colors)):
        all_steps, all_delta_x, all_delta_y = [], [], []

        for run_index, run in enumerate(all_runs):
            steps, delta_x, delta_y = zip(*run)
            all_steps.extend(steps)
            all_delta_x.extend(delta_x)
            all_delta_y.extend(delta_y)

            # Always show individual dots
            ax_x.plot(steps, delta_x, 'o', alpha=0.5, color=color,
                      label=f"{label} Δx run {run_index + 1}" if not combine_datasets else None)
            ax_y.plot(steps, delta_y, 'o', alpha=0.5, color=color,
                      label=f"{label} Δy run {run_index + 1}" if not combine_datasets else None)

        # Compute fit over all points of this dataset
        slope_x, intercept_x, *_ = linregress(all_steps, all_delta_x)
        slope_y, intercept_y, *_ = linregress(all_steps, all_delta_y)
        step_range = np.linspace(min(all_steps), max(all_steps), 100)
        fit_x = slope_x * step_range + intercept_x
        fit_y = slope_y * step_range + intercept_y

        # Show linear fit line
        ax_x.plot(step_range, fit_x, '-', color=color,
                  label=f"{label} Δx fit (y={slope_x:.2f}x+{intercept_x:.2f})")
        ax_y.plot(step_range, fit_y, '-', color=color,
                  label=f"{label} Δy fit (y={slope_y:.2f}x+{intercept_y:.2f})")

    ax_x.set(xlabel='Motor steps', ylabel='Δx (pixels)', title='Pixel shift in X')
    ax_y.set(xlabel='Motor steps', ylabel='Δy (pixels)', title='Pixel shift in Y')
    ax_x.grid(True)
    ax_y.grid(True)
    ax_x.legend()
    ax_y.legend()

    plt.tight_layout()
    plt.savefig(output_file)
    return fit_x, fit_y

    # Voer twee kalibraties uit
data1 = calibrate_mirror1_2D(4,100,2,"up",100)
data2 = calibrate_mirror1_2D(4,100,2,"up",500)
data3 = calibrate_mirror1_2D(4,100,2,"down",100)
data4 = calibrate_mirror1_2D(4,100,2,"down",500)
plot_calibration([data3,data4],"down_steprate_100_vs_500.png",labels=["calibration steprate 100","calibration steprate 500"],combine_datasets=True)
plot_calibration([data1,data2],"up_steprate_100_vs_500.png",labels=["calibration steprate 100","calibration steprate 500"],combine_datasets=True)
