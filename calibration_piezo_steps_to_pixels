import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import linregress
from functions import *
motor = PiezoMotor()
def plot_calibration(calibrations, output_file, labels=None, combine_datasets=False, plot_individual_runs=True, return_fits=True):
    """
    Plot calibration data and compute linear fits for multiple datasets.

    Args:
        calibrations (list): List of calibration datasets, each containing runs with (steps, delta_x, delta_y)
        output_file (str): File path to save the plot
        labels (list, optional): Labels for each dataset. Defaults to numbered labels.
        combine_datasets (bool, optional): If True, combine runs within each dataset for plotting. Defaults to False.
        plot_individual_runs (bool, optional): If True, plot individual run data points. Defaults to True.
        return_fits (bool, optional): If True, return fit parameters. Defaults to True.

    Returns:
        dict: Dictionary containing fit parameters for each dataset {'label': {'slope_x': float, 'intercept_x': float, 'slope_y': float, 'intercept_y': float}}
        or None if return_fits is False

    Raises:
        ValueError: If no calibration data is provided
    """
    if not calibrations:
        raise ValueError("No calibration data provided")

    # Set default labels if none provided
    if labels is None:
        labels = [f"Data {i+1}" for i in range(len(calibrations))]

    # Validate input lengths
    if len(labels) != len(calibrations):
        raise ValueError("Number of labels must match number of datasets")

    # Initialize plot
    colors = plt.cm.tab10(np.linspace(0, 1, len(calibrations)))
    fig, (ax_x, ax_y) = plt.subplots(1, 2, figsize=(12, 5))
    
    fit_results = {}

    for i, (all_runs, label, color) in enumerate(zip(calibrations, labels, colors)):
        all_steps, all_delta_x, all_delta_y = [], [], []

        # Collect all data points
        for run_index, run in enumerate(all_runs):
            steps, delta_x, delta_y = zip(*run)
            all_steps.extend(steps)
            all_delta_x.extend(delta_x)
            all_delta_y.extend(delta_y)

            # Plot individual run points if requested
            if plot_individual_runs:
                ax_x.plot(steps, delta_x, 'o', alpha=0.5, color=color,
                         label=f"{label} Δx run {run_index + 1}" if not combine_datasets else None)
                ax_y.plot(steps, delta_y, 'o', alpha=0.5, color=color,
                         label=f"{label} Δy run {run_index + 1}" if not combine_datasets else None)

        # Plot combined points if requested
        if combine_datasets:
            ax_x.plot(all_steps, all_delta_x, 'o', alpha=0.5, color=color, label=f"{label} Δx")
            ax_y.plot(all_steps, all_delta_y, 'o', alpha=0.5, color=color, label=f"{label} Δy")

        # Compute and plot linear fit
        slope_x, intercept_x, *_ = linregress(all_steps, all_delta_x)
        slope_y, intercept_y, *_ = linregress(all_steps, all_delta_y)
        
        # Store fit results
        fit_results[label] = {
            'slope_x': slope_x,
            'intercept_x': intercept_x,
            'slope_y': slope_y,
            'intercept_y': intercept_y
        }

        # Plot fit line
        step_range = np.linspace(min(all_steps), max(all_steps), 100)
        fit_x = slope_x * step_range + intercept_x
        fit_y = slope_y * step_range + intercept_y
        
        ax_x.plot(step_range, fit_x, '-', color=color,
                 label=f"{label} Δx fit (y={slope_x:.2f}x+{intercept_x:.2f})")
        ax_y.plot(step_range, fit_y, '-', color=color,
                 label=f"{label} Δy fit (y={slope_y:.2f}x+{intercept_y:.2f})")

    # Configure axes
    ax_x.set(xlabel='Motor steps', ylabel='Δx (pixels)', title='Pixel shift in X')
    ax_y.set(xlabel='Motor steps', ylabel='Δy (pixels)', title='Pixel shift in Y')
    ax_x.grid(True)
    ax_y.grid(True)
    ax_x.legend()
    ax_y.legend()

    plt.tight_layout()
    plt.savefig(output_file)
    plt.close()  # Close the figure to free memory

    return fit_results if return_fits else None

# Example usage:
if __name__ == "__main__":
    # Your existing calibration calls
    flipmirror(1)
    data1 = calibrate_mirror1_2D(5, 100, 2, 100, motor)
    data2 = calibrate_mirror1_2D(5, 100, 2, 250, motor)
    data3 = calibrate_mirror1_2D(5, 100,2, 500, motor)
    data4 = calibrate_mirror1_2D(5, 100,2, 1000, motor)
    # Plot with multiple datasets
    fits = plot_calibration(
        [data1,data2, data3, data4],
        "combined_calibration_with_repeats.png",
        labels=["steprate=100","steprate = 250", "steprate = 500", "steprate = 1000"],
        combine_datasets=True,
        plot_individual_runs=True
    )

    # Access fit parameters
    for label, params in fits.items():
        print(f"{label}:")
        print(f"  X-fit: slope={params['slope_x']:.2f}, intercept={params['intercept_x']:.2f}")
        print(f"  Y-fit: slope={params['slope_y']:.2f}, intercept={params['intercept_y']:.2f}")